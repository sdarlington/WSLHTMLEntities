//
//  WSLHTMLEntities.m
//  WSLHTMLEntities
//
//  Created by Stephen Darlington on 05/06/2012.
//  Copyright (c) 2012 Wandle Software Limited. All rights reserved.
//

#import "WSLHTMLEntities.h"
#import "WSLHTMLEntityDefinitions.h"

// Remove dependency on header file generated by Flex by declaring the C types and
// functions that we use here.
typedef void* yyscan_t;
typedef struct yy_buffer_state *YY_BUFFER_STATE;

int WSLlex_init(yyscan_t* yyscanner);
int WSLlex (yyscan_t yyscanner);
int WSLlex_destroy(yyscan_t yyscanner);
void WSLrestart (FILE *input_file ,yyscan_t yyscanner );
YY_BUFFER_STATE WSL_scan_string (const char *yy_str ,yyscan_t yyscanner );
char *WSLget_text (yyscan_t yyscanner );

// And now on to the good stuff...

@interface WSLHTMLEntities ()

+(NSString*)convertHTMLtoString:(NSString*)html scanner:(yyscan_t)scanner;

@end

@implementation WSLHTMLEntities {
    yyscan_t _scanner;
}

-(id)init {
    self = [super init];
    if (self) {
        WSLlex_init(&_scanner);
    }
    return self;
}

-(void)dealloc {
    WSLlex_destroy(_scanner);
#if !__has_feature(objc_arc)
    [super dealloc];
#endif
}

-(NSString*)convertHTMLtoString:(NSString*)html {
    WSLrestart(NULL, _scanner);
    return [WSLHTMLEntities convertHTMLtoString:html scanner:_scanner];
}

+(NSString*)convertHTMLtoString:(NSString*)html {
    yyscan_t scanner;
    
    WSLlex_init(&scanner);
    NSString* retv = [WSLHTMLEntities convertHTMLtoString:html scanner:scanner];
    WSLlex_destroy(scanner);
    return retv;
}

+(NSString*)convertHTMLtoString:(NSString*)html scanner:(yyscan_t)scanner {
    NSData* d = [html dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
    if (d.length == 0) {
        return nil;
    }
    char* text = alloca(d.length + 1);
    text[d.length] = '\0';
    memccpy(text, d.bytes, sizeof(char), d.length);
    
    WSL_scan_string(text, scanner);
    long expression;
    NSMutableString* output = [NSMutableString string];
    while ((expression = WSLlex(scanner))) {
        // TODO: there has to be a more efficient way of doing this...
        switch (expression) {
            case WSL_ENTITY_NOMATCH:
                [output appendString:[NSString stringWithCString:WSLget_text(scanner)
                                                        encoding:NSISOLatin1StringEncoding]];
                break;
            case WSL_ENTITY_HEX_NUMBER:
                // +3 to move past the '&#x'
                expression = strtol(WSLget_text(scanner) + 3, NULL, 16);
                if (expression == 0 && errno == EINVAL) {
                    // TODO: the lexer should always return a valid hex number but we should still have some error handling here
                }
                else {
                    [output appendFormat:@"%C", (unichar)expression];
                }
                break;
            case WSL_ENTITY_NUMBER:
                expression = atoi(&WSLget_text(scanner)[2]);
                // fall through so expression is added to string
            default:
                [output appendFormat:@"%C", (unsigned short) expression];
                break;
        }
    }
    
    return output;
}

@end
